Parfait, on part sur un userbot Telethon propre, minimal, stable, et surtout 100% adapt√© √† ton cas r√©el : deux PDF par jour, toujours envoy√©s par le m√™me bot, dans une conversation priv√©e.
Je te pr√©pare un script clair, robuste, comment√©, que tu pourras lancer sur n‚Äôimporte quel serveur ou machine locale.

üß± Architecture du script
Ton userbot va :
- se connecter en tant que toi (session Telegram)
- √©couter uniquement la conversation priv√©e avec le bot qui t‚Äôenvoie les PDF
- d√©tecter les messages contenant un document PDF
- transf√©rer automatiquement le PDF dans ton canal
- logguer chaque transfert (heure, nom du fichier, etc.)
- ignorer tout le reste
Les horaires (7h20‚Äì7h40 et 19h20‚Äì19h40) ne n√©cessitent aucune logique sp√©ciale :
le script tourne en continu et r√©agit d√®s que le PDF arrive.

üß© √âtape 1 ‚Äî Installer Telethon
pip install telethon



üß© √âtape 2 ‚Äî R√©cup√©rer ton API ID et API HASH
Va sur :
https://my.telegram.org/auth
Puis :
- API Development Tools
- Create new app
- Tu r√©cup√®res :
- api_id
- api_hash

üß© √âtape 3 ‚Äî Script Telethon complet
‚ö†Ô∏è Tu n‚Äôas qu‚Äô√† remplacer :
- API_ID
- API_HASH
- TARGET_CHANNEL (ex : "@mon_canal")
- BOT_USERNAME (ex : "@bot_qui_m_envoie_les_pdfs")

from telethon import TelegramClient, events
import asyncio
import os

API_ID = 123456          # <-- remplace
API_HASH = "abcdef123"   # <-- remplace
SESSION_NAME = "userbot_session"

BOT_USERNAME = "@nom_du_bot"      # <-- remplace
TARGET_CHANNEL = "@ton_canal"     # <-- remplace

client = TelegramClient(SESSION_NAME, API_ID, API_HASH)

@client.on(events.NewMessage(from_users=BOT_USERNAME))
async def handler(event):
    # V√©rifie si le message contient un document
    if not event.message.document:
        return

    # V√©rifie si c'est un PDF
    mime = event.message.document.mime_type
    if mime != "application/pdf":
        return

    # R√©cup√®re le nom du fichier
    file_name = event.message.document.attributes[0].file_name

    print(f"[+] PDF d√©tect√© : {file_name}")

    # T√©l√©charge le PDF localement
    file_path = await event.message.download_media()
    print(f"[+] T√©l√©charg√© : {file_path}")

    # Transfert dans ton canal
    await client.send_file(
        TARGET_CHANNEL,
        file_path,
        caption=f"PDF transf√©r√© automatiquement : {file_name}"
    )

    print(f"[+] Transf√©r√© dans {TARGET_CHANNEL}")

    # Supprime le fichier local apr√®s envoi
    os.remove(file_path)

async def main():
    print("Connexion‚Ä¶")
    await client.start()
    print("Userbot actif. En attente de PDF‚Ä¶")
    await client.run_until_disconnected()

asyncio.run(main())



üß™ √âtape 4 ‚Äî Premier lancement
Au premier run, Telethon va t‚Äôafficher :
Enter your phone number:


Puis il t‚Äôenverra un code Telegram ‚Üí tu le tapes ‚Üí session cr√©√©e.
Ensuite, plus besoin de te reconnecter.

üß© √âtape 5 ‚Äî Ce que le script fait exactement
- Il √©coute uniquement les messages venant de @nom_du_bot
- D√®s qu‚Äôun PDF arrive ‚Üí il le t√©l√©charge ‚Üí le renvoie dans ton canal
- Il supprime le fichier local apr√®s transfert
- Il tourne en continu
- Il ne d√©pend pas des horaires : il r√©agit d√®s que √ßa arrive

üß† Optionnel : logs plus d√©taill√©s
Si tu veux, je peux ajouter :
- un fichier log journalier
- un syst√®me de retry si Telegram rate un upload
- une v√©rification anti‚Äëdoublon
- un watchdog pour red√©marrer le script si crash

üéØ Tu veux que je t‚Äôajoute quoi ?
- Une version TypeScript avec GramJS
- Une version Docker pr√™te √† d√©ployer
- Une version avec logs persistants
- Une version avec alertes en cas d‚Äô√©chec
Dis‚Äëmoi ce que tu pr√©f√®res et je te l‚Äôadapte sur mesure.
